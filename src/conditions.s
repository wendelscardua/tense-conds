;
; File generated by cc65 v 2.19 - Git 884f72637
;
	.fopt		compiler,"cc65 v 2.19 - Git 884f72637"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	on
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.dbg		file, "src/conditions.c", 3014, 1664657334
	.dbg		file, "src/lib/nesdoug.h", 6542, 1664622739
	.dbg		file, "src/lib/neslib.h", 8412, 1664622739
	.dbg		file, "src/conditions.h", 645, 1664657209
	.dbg		file, "src/subrand.h", 146, 1664641459
	.dbg		file, "src/attributes.h", 214, 1664622739
	.dbg		file, "src/globals.h", 543, 1664622739
	.dbg		sym, "multi_vram_buffer_horz", "00", extern, "_multi_vram_buffer_horz"
	.dbg		sym, "subrand8", "00", extern, "_subrand8"
	.dbg		sym, "set_attribute", "00", extern, "_set_attribute"
	.dbg		sym, "temp", "00", extern, "_temp"
	.dbg		sym, "i", "00", extern, "_i"
	.dbg		sym, "j", "00", extern, "_j"
	.dbg		sym, "temp_x", "00", extern, "_temp_x"
	.dbg		sym, "temp_y", "00", extern, "_temp_y"
	.dbg		sym, "temp_int", "00", extern, "_temp_int"
	.import		_multi_vram_buffer_horz
	.import		_subrand8
	.exportzp	_temp_cond
	.export		_condition_row
	.export		_condition_column
	.export		_condition_seconds
	.export		_condition_frames
	.export		_condition_hp
	.export		_condition_type
	.export		_init_conditions
	.export		_add_condition
	.export		_update_condition_pool
	.export		_random_condition
	.import		_set_attribute
	.importzp	_temp
	.importzp	_i
	.importzp	_j
	.importzp	_temp_x
	.importzp	_temp_y
	.importzp	_temp_int
	.export		_num_conditions_in_pool
	.export		_i_cond
	.export		_j_cond
	.export		_temp_cond_2
	.export		_cond_pool_weight
	.export		_condition_pool
	.export		_unlocked
	.export		_empty_timer
	.export		_condition_icon
	.export		_unlockables
	.export		_weights
	.export		_starting_health

.segment	"RODATA"

_empty_timer:
	.byte	$F0
	.byte	$E0
_condition_icon:
	.byte	$D0
	.byte	$D1
	.byte	$D2
	.byte	$D3
_unlockables:
	.byte	$01
	.byte	$02
	.byte	$02
	.res	1,$00
_weights:
	.byte	$00
	.byte	$0A
_starting_health:
	.byte	$FF
	.byte	$03

.segment	"BSS"

.segment	"ZEROPAGE"
_temp_cond:
	.res	1,$00
.segment	"BSS"
_condition_row:
	.res	16,$00
_condition_column:
	.res	16,$00
_condition_seconds:
	.res	16,$00
_condition_frames:
	.res	16,$00
_condition_hp:
	.res	16,$00
_condition_type:
	.res	16,$00
.segment	"ZEROPAGE"
_num_conditions_in_pool:
	.res	1,$00
_i_cond:
	.res	1,$00
_j_cond:
	.res	1,$00
_temp_cond_2:
	.res	1,$00
_cond_pool_weight:
	.res	1,$00
.segment	"BSS"
_condition_pool:
	.res	2,$00
_unlocked:
	.res	2,$00

; ---------------------------------------------------------------
; void __near__ init_conditions (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_init_conditions: near

	.dbg	func, "init_conditions", "00", extern, "_init_conditions"

.segment	"CODE"

;
; num_conditions_in_pool = 0;
;
	.dbg	line, "src/conditions.c", 64
	lda     #$00
	sta     _num_conditions_in_pool
;
; for(i = 0; i < MAX_CONDITIONS; i++) {
;
	.dbg	line, "src/conditions.c", 65
	sta     _i
L0007:	lda     _i
	cmp     #$10
	bcs     L0003
;
; condition_hp[i] = 0;
;
	.dbg	line, "src/conditions.c", 66
	ldy     _i
	lda     #$00
	sta     _condition_hp,y
;
; for(i = 0; i < MAX_CONDITIONS; i++) {
;
	.dbg	line, "src/conditions.c", 65
	inc     _i
	jmp     L0007
;
; }
;
	.dbg	line, "src/conditions.c", 68
L0003:	rts

	.dbg	line
.endproc

; ---------------------------------------------------------------
; void __near__ add_condition (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_add_condition: near

	.dbg	func, "add_condition", "00", extern, "_add_condition"

.segment	"CODE"

;
; for(i_cond = 0; i_cond < MAX_CONDITIONS; i_cond++) {
;
	.dbg	line, "src/conditions.c", 72
	lda     #$00
	sta     _i_cond
L0015:	lda     _i_cond
	cmp     #$10
	bcs     L0016
;
; if (condition_hp[i_cond] == 0) break;
;
	.dbg	line, "src/conditions.c", 73
	ldy     _i_cond
	lda     _condition_hp,y
	beq     L0016
;
; for(i_cond = 0; i_cond < MAX_CONDITIONS; i_cond++) {
;
	.dbg	line, "src/conditions.c", 72
	inc     _i_cond
	jmp     L0015
;
; if (i_cond >= MAX_CONDITIONS) return; // TODO: maybe overwrite another one?
;
	.dbg	line, "src/conditions.c", 75
L0016:	lda     _i_cond
	cmp     #$10
	bcc     L0017
;
; }
;
	.dbg	line, "src/conditions.c", 88
	rts
;
; condition_row[i_cond] = temp_y;
;
	.dbg	line, "src/conditions.c", 77
L0017:	ldy     _i_cond
	lda     _temp_y
	sta     _condition_row,y
;
; condition_column[i_cond] = temp_x;
;
	.dbg	line, "src/conditions.c", 78
	ldy     _i_cond
	lda     _temp_x
	sta     _condition_column,y
;
; condition_type[i_cond] = temp_cond;
;
	.dbg	line, "src/conditions.c", 79
	ldy     _i_cond
	lda     _temp_cond
	sta     _condition_type,y
;
; condition_seconds[i_cond] = 0;
;
	.dbg	line, "src/conditions.c", 80
	ldy     _i_cond
	lda     #$00
	sta     _condition_seconds,y
;
; condition_hp[i_cond] = starting_health[temp_cond];
;
	.dbg	line, "src/conditions.c", 81
	lda     #<(_condition_hp)
	ldx     #>(_condition_hp)
	clc
	adc     _i_cond
	bcc     L000D
	inx
L000D:	sta     ptr1
	stx     ptr1+1
	ldy     _temp_cond
	lda     _starting_health,y
	ldy     #$00
	sta     (ptr1),y
;
; condition_frames[i_cond] = subrand8(16);
;
	.dbg	line, "src/conditions.c", 82
	lda     #<(_condition_frames)
	ldx     #>(_condition_frames)
	clc
	adc     _i_cond
	bcc     L000F
	inx
L000F:	jsr     pushax
	lda     #$10
	jsr     _subrand8
	ldy     #$00
	jsr     staspidx
;
; update_condition_pool();
;
	.dbg	line, "src/conditions.c", 83
	jsr     _update_condition_pool
;
; temp_int = NTADR_A(2 * temp_x, 2 * temp_y);
;
	.dbg	line, "src/conditions.c", 84
	ldx     #$00
	lda     _temp_y
	asl     a
	bcc     L0011
	inx
L0011:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _temp_x
	asl     a
	bcc     L0012
	inx
L0012:	ora     ptr1
	sta     _temp_int
	txa
	ora     tmp1
	ora     #$20
	sta     _temp_int+1
;
; multi_vram_buffer_horz(empty_timer, 2, temp_int);
;
	.dbg	line, "src/conditions.c", 85
	jsr     decsp3
	lda     #<(_empty_timer)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_empty_timer)
	sta     (sp),y
	tya
	ldy     #$00
	sta     (sp),y
	lda     _temp_int
	ldx     _temp_int+1
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz(condition_icon[temp_cond], 2, temp_int + 0x20);
;
	.dbg	line, "src/conditions.c", 86
	jsr     decsp3
	ldx     #$00
	lda     _temp_cond
	asl     a
	bcc     L0014
	inx
	clc
L0014:	adc     #<(_condition_icon)
	tay
	txa
	adc     #>(_condition_icon)
	tax
	tya
	ldy     #$01
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	tya
	ldy     #$00
	sta     (sp),y
	lda     _temp_int
	ldx     _temp_int+1
	clc
	adc     #$20
	bcc     L0010
	inx
L0010:	jsr     _multi_vram_buffer_horz
;
; set_attribute(0x01);
;
	.dbg	line, "src/conditions.c", 87
	lda     #$01
	jmp     _set_attribute

	.dbg	line
.endproc

; ---------------------------------------------------------------
; void __near__ update_condition_pool (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_update_condition_pool: near

	.dbg	func, "update_condition_pool", "00", extern, "_update_condition_pool"

.segment	"CODE"

;
; if (unlocked[temp_cond]) return;
;
	.dbg	line, "src/conditions.c", 91
	ldy     _temp_cond
	lda     _unlocked,y
	bne     L0006
;
; unlocked[temp_cond] = 1;
;
	.dbg	line, "src/conditions.c", 92
	ldy     _temp_cond
	lda     #$01
	sta     _unlocked,y
;
; for(i_cond = 0; (temp_cond_2 = unlockables[temp_cond][i_cond]) != CondTotal; i_cond++) {
;
	.dbg	line, "src/conditions.c", 93
	lda     #$00
	sta     _i_cond
	tax
L0015:	lda     _temp_cond
	asl     a
	bcc     L0014
	ldx     #$01
	clc
L0014:	adc     #<(_unlockables)
	sta     ptr1
	txa
	adc     #>(_unlockables)
	sta     ptr1+1
	ldy     _i_cond
	lda     (ptr1),y
	sta     _temp_cond_2
	cmp     #$02
	beq     L0006
;
; for(j_cond = 0; j < num_conditions_in_pool; j++) {
;
	.dbg	line, "src/conditions.c", 94
	lda     #$00
	sta     _j_cond
	tax
L0016:	lda     _j
	cmp     _num_conditions_in_pool
	bcs     L0017
;
; if (condition_pool[j_cond] == temp_cond_2) break;
;
	.dbg	line, "src/conditions.c", 95
	ldy     _j_cond
	lda     _condition_pool,y
	cmp     _temp_cond_2
	beq     L0017
;
; for(j_cond = 0; j < num_conditions_in_pool; j++) {
;
	.dbg	line, "src/conditions.c", 94
	inc     _j
	jmp     L0016
;
; if (j == num_conditions_in_pool) {
;
	.dbg	line, "src/conditions.c", 97
L0017:	lda     _j
	cmp     _num_conditions_in_pool
	bne     L0018
;
; condition_pool[num_conditions_in_pool] = temp_cond_2;
;
	.dbg	line, "src/conditions.c", 98
	ldy     _num_conditions_in_pool
	lda     _temp_cond_2
	sta     _condition_pool,y
;
; num_conditions_in_pool++;
;
	.dbg	line, "src/conditions.c", 99
	inc     _num_conditions_in_pool
;
; cond_pool_weight += weights[temp_cond_2];
;
	.dbg	line, "src/conditions.c", 100
	ldy     _temp_cond_2
	lda     _weights,y
	clc
	adc     _cond_pool_weight
	sta     _cond_pool_weight
;
; for(i_cond = 0; (temp_cond_2 = unlockables[temp_cond][i_cond]) != CondTotal; i_cond++) {
;
	.dbg	line, "src/conditions.c", 93
L0018:	inc     _i_cond
	jmp     L0015
;
; }
;
	.dbg	line, "src/conditions.c", 103
L0006:	rts

	.dbg	line
.endproc

; ---------------------------------------------------------------
; enum $anon-enum-0001 __near__ random_condition (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_random_condition: near

	.dbg	func, "random_condition", "00", extern, "_random_condition"

.segment	"CODE"

;
; temp = subrand8(cond_pool_weight);
;
	.dbg	line, "src/conditions.c", 106
	lda     _cond_pool_weight
	jsr     _subrand8
	sta     _temp
;
; for(i_cond = 0; i_cond < num_conditions_in_pool; i_cond) {
;
	.dbg	line, "src/conditions.c", 107
	lda     #$00
	sta     _i_cond
	tax
L000A:	lda     _i_cond
	cmp     _num_conditions_in_pool
	bcs     L000B
;
; temp_cond = condition_pool[i_cond];
;
	.dbg	line, "src/conditions.c", 108
	ldy     _i_cond
	lda     _condition_pool,y
	sta     _temp_cond
;
; if (temp < weights[temp_cond]) return temp_cond;
;
	.dbg	line, "src/conditions.c", 109
	lda     _temp
	ldy     _temp_cond
	cmp     _weights,y
	bcs     L0007
	lda     _temp_cond
	rts
;
; temp -= weights[temp_cond];
;
	.dbg	line, "src/conditions.c", 110
L0007:	ldy     _temp_cond
	lda     _weights,y
	eor     #$FF
	sec
	adc     _temp
	sta     _temp
;
; for(i_cond = 0; i_cond < num_conditions_in_pool; i_cond) {
;
	.dbg	line, "src/conditions.c", 107
	jmp     L000A
;
; return CondConditioner; // should never happen
;
	.dbg	line, "src/conditions.c", 112
L000B:	lda     #$00
;
; }
;
	.dbg	line, "src/conditions.c", 113
	rts

	.dbg	line
.endproc

